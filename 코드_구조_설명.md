# 에너지 스펙트럼 및 영상 재구성 시간 기반 데이터 처리 구조

## 개요
이 시스템은 Setting popup 창에서 사용자가 입력한 시간만큼의 데이터를 불러와서 에너지 스펙트럼과 영상 재구성을 수행합니다.

## 전체 데이터 흐름

```
[Setting Popup] → [Config] → [ViewModel] → [LahgiApi] → [C++ Wrapper] → [LahgiControl] → [데이터 필터링] → [UI 표시]
```

## 1. 설정 입력 (Setting Popup)

### 1.1 에너지 스펙트럼 시간 설정
- **위치**: `SettingWindow.xaml` / `MainWindow.xaml` (Setting Popup)
- **설정 항목**: "누적 시간(초)" (`SpectrumTime`)
- **기본값**: `Config.SpectrumEffectTime` (기본값: 10초)
- **바인딩**: `Binding SpectrumVM.SpectrumTime`

### 1.2 영상 재구성 시간 설정
- **위치**: `SettingWindow.xaml` / `MainWindow.xaml` (Setting Popup)
- **설정 항목**: "누적 시간(초)" (`ReconMeasurTime`)
- **기본값**: `Config.ReconMeasurTime` (기본값: 20초)
- **바인딩**: `Binding ReconstructionImageVM.ReconMeasurTime`

## 2. ViewModel 계층

### 2.1 SpectrumViewModel (에너지 스펙트럼)
**파일**: `HUREL Imager GUI\ViewModel\HomeView\SpectrumViewModel.cs`

#### 주요 속성
```csharp
public uint SpectrumTime { get; set; }  // 설정된 누적 시간(초)
```

#### 초기화
```csharp
public SpectrumViewModel()
{
    SpectrumTime = App.GlobalConfig.SpectrumEffectTime;  // Config에서 초기값 로드
}
```

#### 데이터 로딩 로직
**위치**: `SpectrumViewModel.cs` (약 680-720줄)

```csharp
// StatusUpdate 이벤트 핸들러에서 호출
switch (_spectrumCases)
{
    case eSpectrumCases.Scatter:
        spectrum = LahgiApi.GetScatterSumSpectrumByTime(SpectrumTime);
        break;
    case eSpectrumCases.Absorber:
        spectrum = LahgiApi.GetAbsorberSumSpectrumByTime(SpectrumTime);
        break;
    case eSpectrumCases.All:
        spectrum = LahgiApi.GetSumSpectrumEnergyByTime(SpectrumTime);
        break;
    case eSpectrumCases.ByChannel:
        spectrum = LahgiApi.GetSpectrumByTime(GetActualFpgaChannelNumber(), SpectrumTime);
        break;
}

// 스펙트럼 데이터를 UI에 바인딩
EnergySpectrum = new ObservableCollection<HistoEnergy>(spectrum.HistoEnergies);
```

### 2.2 ReconstructionImageViewModel (영상 재구성)
**파일**: `HUREL Imager GUI\ViewModel\HomeView\ReconstructionImageViewModel.cs`

#### 주요 속성
```csharp
public int ReconMeasurTime { get; set; }   // 설정된 누적 시간(초)
public int ReconMeasurCount { get; set; }  // 누적 카운트 수
```

#### 초기화
```csharp
public ReconstructionImageViewModel()
{
    ReconMeasurTime = App.GlobalConfig.ReconMeasurTime;   // 기본값: 20초
    ReconMeasurCount = App.GlobalConfig.ReconMeasurCount; // 기본값: 300
}
```

#### 데이터 로딩 로직
**위치**: `ReconstructionImageViewModel.cs` (약 185-193줄)

```csharp
// StatusUpdate 이벤트 핸들러에서 호출
if (ReconSpace == eReconSpace.Pointcloud)
    (tmpCode, tmpCompton, tmpHybrid) = LahgiApi.GetRadation2dImageCount(
        ReconMeasurCount, S2M, Det_W, ResImprov, M2D, 
        MinValuePortion, ReconMaxValue, ReconMeasurTime, LabelingCheck);
else
    (tmpCode, tmpCompton, tmpHybrid) = LahgiApi.GetRadation2dImageCount(
        ReconMeasurCount, S2M, Det_W, ResImprov, M2D, 58, 87, ImgSize, 
        MinValuePortion, ReconMaxValue, ReconMeasurTime, false, LabelingCheck);
```

## 3. LahgiApi 계층 (C# Wrapper)

### 3.1 에너지 스펙트럼 API
**파일**: `Hurel Radiation Imager\Lahgi Class.cs`

#### GetSumSpectrumEnergyByTime
```csharp
public static SpectrumEnergyNasa GetSumSpectrumEnergyByTime(uint time)
{
    List<double[]> eCount = new List<double[]>();
    lahgiWrapper.GetSumSpectrumByTime(ref eCount, time);  // C++ 호출
    
    List<HistoEnergy> histoEnergy = new List<HistoEnergy>();
    for (int i = 0; i < eCount.Count; i++)
    {
        histoEnergy.Add(new HistoEnergy(eCount[i][0], Convert.ToInt32(eCount[i][1])));
    }
    return new SpectrumEnergyNasa(histoEnergy);
}
```

#### GetScatterSumSpectrumByTime
```csharp
public static SpectrumEnergyNasa GetScatterSumSpectrumByTime(uint time)
{
    List<double[]> eCount = new List<double[]>();
    lahgiWrapper.GetScatterSumSpectrumByTime(ref eCount, time);
    // ... 히스토그램 생성
}
```

#### GetAbsorberSumSpectrumByTime
```csharp
public static SpectrumEnergyNasa GetAbsorberSumSpectrumByTime(uint time)
{
    // 유사한 구조
}
```

### 3.2 영상 재구성 API
**파일**: `Hurel Radiation Imager\Lahgi Class.cs`

#### GetRadation2dImageCount
```csharp
public static (BitmapImage?, BitmapImage?, BitmapImage?) GetRadation2dImageCount(
    int count, double s2M, double det_W, double resImprov, double m2D, 
    double minValuePortion, int maxValue, int time = 0, bool labeling = false)
{
    // C++ Wrapper 호출
    var outData = lahgiWrapper.GetRadation2dImageCount(
        count, s2M, det_W, resImprov, m2D, minValuePortion, time, maxValue, labeling);
    
    // BitmapImage로 변환하여 반환
    return (imgCoded, imgCompton, imgHybrid);
}
```

## 4. C++ Wrapper 계층

### 4.1 에너지 스펙트럼 Wrapper
**파일**: `SLAM wrapper\CppWrapper.cpp`

#### GetScatterSumSpectrum
```cpp
std::vector<BinningEnergy> GetScatterSumSpectrum(int time)
{
    // 시간 기반으로 에너지 데이터 필터링
    std::vector<EnergyTimeData> lmData = 
        LahgiControl::instance().GetListedEnergyTimeData(time * 1000);
    
    // 히스토그램 생성
    EnergySpectrum spectClass = EnergySpectrum(10, 3000);
    for (int i = 0; i < lmData.size(); ++i)
    {
        if (lmData[i].InteractionChannel < 8)  // Scatter 채널만
        {
            spectClass.AddEnergy(lmData[i].Energy);
        }
    }
    return spectClass.GetHistogramEnergy();
}
```

### 4.2 영상 재구성 Wrapper
**파일**: `SLAM wrapper\CppWrapper.cpp`

#### GetRadation2dImageCount
```cpp
std::tuple<sBitMapUnmanged, sBitMapUnmanged, sBitMapUnmanged> 
GetRadation2dImageCount(int count, double s2M, ..., int time, int maxValue)
{
    // 시간 기반으로 List Mode Data 필터링
    RadiationImage radimage(
        LahgiControl::instance().GetEfectListedListModeData(count, time * 1000), 
        s2M, det_W, resImprov, m2D, maxValue);
    
    // 이미지 생성 및 반환
    return std::make_tuple(GetCvToPointers(...), ...);
}
```

## 5. LahgiControl (C++ 코어 로직)

### 5.1 시간 기반 에너지 데이터 필터링
**파일**: `Image reconstruction\LahgiControl.cpp`

#### GetListedEnergyTimeData
```cpp
std::vector<EnergyTimeData> GetListedEnergyTimeData(long long timeInMiliSecond)
{
    std::chrono::milliseconds t = std::chrono::duration_cast<...>(
        std::chrono::system_clock::now().time_since_epoch());
    
    size_t getIndexStart = 0;
    
    // 역순으로 검색하여 시간 범위 내의 데이터 찾기
    for (int i = size - 1; i > 0; --i)
    {
        if (t.count() - mListedEnergyTimeData[i].InteractionTimeInMili.count() 
            > timeInMiliSecond)
        {
            getIndexStart = i;
            break;
        }
    }
    
    // 시간 범위 내의 데이터만 반환
    for (int i = getIndexStart; i < size; ++i)
    {
        lmData.push_back(mListedEnergyTimeData[i]);
    }
    
    return lmData;
}
```

**핵심 로직**:
- 현재 시간에서 `timeInMiliSecond` 이전의 데이터를 필터링
- `mListedEnergyTimeData`는 시간순으로 정렬된 에너지 데이터 버퍼
- 역순 검색으로 효율적으로 시작 인덱스 찾기

### 5.2 시간 기반 List Mode Data 필터링
**파일**: `Image reconstruction\LahgiControl.cpp`

#### GetEfectListedListModeData
```cpp
std::vector<ListModeData> GetEfectListedListModeData(int nEfectCount, long long time)
{
    if (time > 0)
    {
        std::chrono::milliseconds t = std::chrono::duration_cast<...>(
            std::chrono::system_clock::now().time_since_epoch());
        long long currentTime = t.count();
        
        int nCount = 0;
        
        // 역순으로 검색
        for (int i = size - 1; i > 0; --i)
        {
            long long interactionTime = mListedListModeData[i].InteractionTimeInMili.count();
            
            // 시간 범위를 벗어나거나 카운트 초과 시 중단
            if (currentTime - interactionTime > time || nCount > nEfectCount)
            {
                break;
            }
            
            nCount++;
            lmData.push_back(mListedListModeData[i]);
        }
    }
    else
    {
        // 시간 제한 없이 최근 nEfectCount개만 반환
        int getIndexStart = size - nEfectCount;
        for (int i = getIndexStart; i < size; ++i)
        {
            lmData.push_back(mListedListModeData[i]);
        }
    }
    
    return lmData;
}
```

**핵심 로직**:
- `time > 0`: 현재 시간에서 `time` 밀리초 이전의 데이터 필터링
- `nEfectCount`: 최대 반환할 데이터 개수 제한
- 두 조건을 모두 만족하는 최근 데이터만 반환

## 6. 데이터 저장 구조

### 6.1 Config (설정 저장)
**파일**: `HUREL Imager GUI\Config\Config.cs`

```csharp
public class Config
{
    // 에너지 스펙트럼
    public uint SpectrumEffectTime { get; set; } = 10;  // 기본값: 10초
    
    // 영상 재구성
    public int ReconMeasurTime { get; set; } = 20;      // 기본값: 20초
    public int ReconMeasurCount { get; set; } = 300;    // 기본값: 300개
}
```

### 6.2 데이터 버퍼 (C++)
**파일**: `Image reconstruction\LahgiControl.h`

```cpp
class LahgiControl
{
private:
    // 시간순으로 정렬된 데이터 버퍼
    tbb::concurrent_vector<ListModeData> mListedListModeData;
    tbb::concurrent_vector<EnergyTimeData> mListedEnergyTimeData;
    
    // 실시간으로 데이터 추가
    void AddListModeData(...);
};
```

## 7. 업데이트 주기

### 7.1 에너지 스펙트럼
- **트리거**: `LahgiApi.StatusUpdate` 이벤트
- **조건**: `lahgiApiEnvetArgs.State == eLahgiApiEnvetArgsState.Spectrum`
- **주기**: 실시간으로 업데이트 (타이머 기반)

### 7.2 영상 재구성
- **트리거**: `LahgiApi.StatusUpdate` 이벤트
- **조건**: `lahgiApiEnvetArgs.State == eLahgiApiEnvetArgsState.SlamRadImage`
- **조건**: `LahgiApi.TimerBoolSlamRadImage == true`
- **주기**: 실시간으로 업데이트 (타이머 기반)

## 8. 시간 단위 변환

### 8.1 에너지 스펙트럼
- **UI 입력**: 초(seconds)
- **C++ 전달**: 초 → 밀리초 변환 (`time * 1000`)

### 8.2 영상 재구성
- **UI 입력**: 초(seconds)
- **C++ 전달**: 초 → 밀리초 변환 (`time * 1000`)

## 요약

1. **사용자 입력**: Setting popup에서 시간(초) 입력
2. **Config 저장**: 입력값이 `Config`에 저장됨
3. **ViewModel 로드**: ViewModel이 Config에서 초기값 로드
4. **실시간 업데이트**: StatusUpdate 이벤트로 주기적 업데이트
5. **시간 필터링**: C++ 레벨에서 현재 시간 기준으로 지정된 시간 범위의 데이터만 필터링
6. **데이터 처리**: 필터링된 데이터로 스펙트럼/영상 생성
7. **UI 표시**: 생성된 데이터를 UI에 바인딩하여 표시

**핵심 포인트**:
- 모든 시간 필터링은 **현재 시간 기준 역순 검색**으로 수행
- 데이터는 시간순으로 정렬된 버퍼에 저장됨
- 시간 범위를 벗어난 오래된 데이터는 자동으로 제외됨
